## 在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。

#### count（*）的实现方式

不同的MySQL引擎中，count(*)有不同的实现方式

- MyISAM引擎把一个表的总行数存在了磁盘上，count(*)会直接返回这个数，但是一旦加了where条件，也不能快速返回；
- InnoDB引擎执行count（*）的时候，由于MVCC的存在，一个事务能看到多少行是不确定的，所以需要把数据一行一行地从引擎里面读出来，然后判断数据的可见性，如此累积计数；

**InnoDB优化措施**

InnoDB是索引组织表，普通索引树要比主键索引树小很多，对于count（*）这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的，因此，优化器会找**最小的**那颗树来遍历

**为什么不能用show table status里的行数？**

这个行数是通过索引采样估算出来的，误差可能达到40%到50%

####  不同的count用法

count()是一个聚合函数，对于返回的结果集，一行行判断，如果count函数的参数不是NULL，累计值就加1，否则不加，最后返回累计值。

- **count(主键id)**：遍历整张表，每行的id都取出来，返回给server层，server层判断字段不可空，按行累加；
- **count(1)**：遍历整张表，但是不取值，server层收到的所有行都是1，server层判断字段不为空，按行累加。之所以比count(主键)快，因为从引擎返回id会涉及到解析数据行，以及拷贝字段值的操作；
- **count(字段)**：如果字段定义为not null，逐行从记录里读出这个字段，server层判断字段不为空，按行累加；如果是允许为null的情况下，server层判断字段可为null，字段取出还需判断是否为null，再进行累加；
- **count(*)**：专门做了优化，不取值，按行累加。

**效率：count(字段) < count(主键 id) < count(1) ≈ count(*)**