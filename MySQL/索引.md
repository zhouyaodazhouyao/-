### 索引的出现其实就是为了提高数据查询的效率，就像书的目录一样

#### InnoDB的索引模型

InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为**索引组织表**。InnoDB使用的索引模型是B+树，所以数据都是存储在B+树当中的。

根据叶子节点的内容，索引分为主键索引和非主键索引

- **主键索引**：叶子节点存的是整行数据，InnoDB中，主键索引也被称为聚簇索引（Clustered index）。
- **非主键索引**：叶子节点存的是主键的值，InnoDB中，非主键索引也被称为二级索引（secondary index）。

也就是说，基于非主键索引的查询一般要多扫描一颗索引树，回到主键索引树搜索的过程，叫做**回表**

#### 索引维护

B+树为了索引有序性，在插入新值的时候需要做必要的维护。

插入数据时，如果数据所在的数据页已经满了，会申请一个新的数据页，然后挪动部分数据过去，这个过程称为**页分裂**。页分裂会影响性能，也会降低空间利用率。

删除数据时，与之相反的，如果数据页的空间利用率过低，就会将数据页做合并。

```
建表时用自增主键而不用业务字段做主键的原因：
1.主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间就越小
2.自增主键新增记录都是追加操作，不会发生挪动其他记录以及页分裂的操作，性能更好
```

#### 覆盖索引

如果索引中包含了所有查询需要的字段，就不需要回表，直接返回，这时我们称这样的索引为覆盖索引。覆盖索引会显著提升查询性能，但是索引字段的维护是有代价的，简历冗余索引来支持覆盖索引时需要权衡考虑。

#### 最左前缀原则

B+树索引，利用索引的“最左前缀”，来定位记录。索引项是按照索引定义里面出现的字段顺序排序的。只要满足最左前缀，就可以利用这个索引来极速检索。这个最左前缀，可以是联合索引最左N个字段，也可以是字符串索引的最左M个字符。

#### 索引下推

过滤条件中有一部分满足最左前缀原则，可以使用到联合索引的情况下，若必须回表，且查询条件中有用到联合索引其他字段的部分，会在回表前再近一步过滤，以减少回表。

#### 索引失效

对索引字段做函数操作，**即便没有改变索引的有序性**，优化器也会放弃使用索引的树搜索功能，改为全索引扫描。尤其要注意的是，有些SQL语句可能涉及到**隐式类型转换**或者**隐式字符编码转换**，无形中消除了索引的优势。

#### Change Buffer

当需要更新一条数据时，如果数据页恰好在内存中就直接更新，如果没在内存中的话，在不影响数据一致性的前提下，InnoDB会将这些更新操作缓存在change buffer中，等到下次这个数据页读入内存中了，再执行change buffer中有关这个页的操作，这个过程称为**merge**。

[^注]: 唯一索引需要判断唯一性，必须将数据页读入内存中，因而只有普通索引可以使用change buffer

**merge的执行时机**

- 相应的数据页读入内存
- 定期merge
- 数据库正常关闭
- redo log写满（情况不多）

**使用场景：**适用于写多读少的业务，如果是唯一索引比较多，或者写入之后马上需要查询的业务模式，反倒会起到副作用

#### 字符串创建索引的场景

1. 直接创建完整索引，不过可能比较占用空间
2. 创建前缀索引，节省空间，但是要选择合适的长度来保证区分度，同时还会增加查询扫描次数，并且不能使用覆盖索引
3. 倒序存储，再创建前缀索引，用于绕过字符串本身前缀区分度不够的问题
4. 创建hash字段索引，查询性能稳定，有额外的存储计算消耗

[^注]: 3、4两种方法都无法支持范围扫描

