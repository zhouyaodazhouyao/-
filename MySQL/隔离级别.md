#### 事务

保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中，事务是在**引擎层**实现的。原生的MYISAM不支持事务

#### 隔离性与隔离级别

SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serialization）

[^注]: **隔离级别越快，效率越差**

| 读未提交     | 事务未做提交时，变更信息便能被另一个事务看到                 |
| ------------ | ------------------------------------------------------------ |
| **读提交**   | **事务提交后，变更的信息才能被另一个事务看到**               |
| **可重复读** | **一个事务执行过程中看到的数据，总是和该事务启动时看到的数据是一致的** |
| **串行化**   | **对同一行记录，写会加写锁，读会加读锁，出现读写锁或者写锁冲突时，后一个事务要等前一个事务执行完毕，才能继续执行** |

[^小知识]: Oracle的默认隔离级别是读提交

#### 一致性读具体实现

实现上，在**读提交和可重复读级别**下，数据库里面会创建一个**视图**，访问时以视图的逻辑结果为准。不同的是，读提交级别的视图是在每条sql语句执行的时候都会生成，而可重复读级别的视图是在事务启动的时候创建的，整个事务存在期间都用这个视图；**读未提交**直接返回最新值，没有视图的概念；**串行化**直接用加锁的方式避免并行访问。

```
MySQL中的两个视图：
1.view，查询语句定义的虚拟表。
2.consistent read view，InnoDB在实现MVCC时用到的一致性视图，用于支持读提交级别和可重复读级别的实现。没有物理结构，描述事务执行期间用来定义“我能看到什么数据”。
```

**那么每个视图对应的数据都是怎么来的呢？**

实际上每条记录在更新的时候都会同时记录一条回滚操作。最新值可以通过回滚操作计算出过往的值。如下图

<img src="D:\Users\zhou_yao\workspace\just-for-review-and-zhuangB\MySQL\mvcc.png" alt="mvcc" style="zoom: 80%;" />

同一条记录，在系统中可以存在多个版本，这就是数据库的**多版本并发控制（MVCC）**。对于视图A，如果想得到最初结果3，需从当前值2依次向前推算出来。同时回滚段并不会一直保留，当系统中不存在比这个记录更老的视图的时候，就会将这部分回滚段删除，这也就是不建议使用长事务的原因之一，因为长事务会一直保留老视图，导致回滚段不能删除，耗费大量存储空间。

[^注]: **除了占用存储资源，长事务还会耗费锁资源，拖垮整个系统，后续进行补充**

**那么，接下来的问题就是，MySQL是怎么迅速创建一致性视图的？**

InnoDB每个事务有一个唯一的事务ID，叫做**transaction id**。事务开始的时候向InnoDB的事务系统申请，按申请顺序**严格递增**。上面说过，同一条记录有多个版本，每次更新数据会生成新的版本，同时把事务的transaction id赋值给这个版本，记为**row trx_id**。旧版本的数据可以通过undo log计算获取到。

基于此，事务启动时就可以划定一致性视图了，InnoDB为每个事务构造了一个数组，用来保存事务启动的瞬间，当前所有**启动了还没提交**的所有事务ID。其中，数组里事务ID最小值记为低水位，当前系统里已经创建过的事务ID最大值加1记为高水位。

这个视图数组把所有的row trx_id划成了如下几种不同的情况。

![row trx_id set](D:\Users\zhou_yao\workspace\just-for-review-and-zhuangB\MySQL\row trx_id set.png)

对于一个数据版本的row trx_id，其可见性遵从如下规则：

- 如果落在低水位之后或者是和自身事务transaction id相同，证明这个数据是已经提交过的，或者是自己修改的，那么应该是可见的；
- 如果落在高水位之前，证明这个数据版本是将来新启动的事务提交的，不可见；
- 如果在低水位和高水位之间，那么要看row trx_id在不在事务启动时构造的**启动未提交事务数组**中，如果在，那么表示事务还没有提交，不可见，如果不在，标明事务已经提交了，可见

#### 一致性读模式下的更新模式

如果按照上述所说规则进行更新，那么后续事务的更新就会被忽略掉，因而**更新数据都是先读后写的，这个读，读最新的值，成为“当前读”（current read）**。

不止是修改删除语句，select加锁的模式，例如for update、lock in share mode都会使用当前读。

#### 读提交逻辑和可重复读区别

- 可重复读级别下，只需要在事务开始的时候创建一致性视图，之后事务里的查询都公用这个一致性视图
- 读提交级别下，每次执行语句前都会重新算出一个新的一致性视图