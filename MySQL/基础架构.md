## MySQL分为Server层和存储引擎层两部分，具体结构如下图

![MySQL-query](D:\Users\zhou_yao\workspace\just-for-review-and-zhuangB\MySQL\MySQL-query.png)



**Server层**包括连接器，分析器，优化器和执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（日期，时间，数学和加密函数等）。所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。

**存储引擎层**负责数据的存储和提取，插件式的，支持InnoDb，MyISAM等多个存储引擎，其中InnoDB为默认存储引擎。



#### Server层各组件

- **连接器**

负责跟客户端建立连接、获取权限、维持和管理连接。需要注意的是，连接建立以后，权限就确定下来。如果发生变化，需要下次重新连接时生效

长连接是数次请求使用同一个请求，短连接是查询几次后就断开，后续重连。由于数据库的连接过程是高cost的，所以一般建议使用长连接，由此引发的问题是，长连接使用的内存管理在连接对象里，容易导致OOM。

解决方案：1.定期断开长连接，或者判断如果有大内存使用之后就断开。2. MySQL 5.7以上版本，大查询之后mysql_reset_connection初始化连接资源

- **查询缓存**

查询的语句和结果以key-value的形式存在内存中，命中直接返回。

不过缓存很鸡肋，表有更新会将这个表的所有缓存直接清空，更新较多的表命中率极低，只有静态表才能发挥一下优势。MySQL 8.0已经将这部分功能移除

- **分析器**

词法分析，语法分析，看查询语句是否满足MySQL语法。报错时一般会提示第一个出现错误的位置，关注“use near”这个位置。

- **优化器**

语句确定之后，优化器来决定选择哪个索引，两个表之前的join顺序，以确定最高效的执行方案

- **执行器**

执行查询语句，执行之前需进行权限校验，校验通过会执行查询语句，从存储引擎中逐条拿出符合条件的行

[^权限校验]: 优化器之前也做了preCheck校验，但是无法对运行时的表进行权限验证，比如使用了触发器的情况



#### 日志模块

查询语句只用到上述各组件即可完成操作，更新语句也需要用到上述组件，同时还用到了MySQL的日志模块，即**redo log**（重做日志）和**binlog**（归档日志）

##### redo log（重做日志）

MySQL如果每次写入记录都走磁盘，IO成本过高，为了提高效率，使用了**WAL（Write-Ahead Logging）技术**，先写日志，后写磁盘。

具体来说，当有一条记录需要更新时，InnoDB引擎会把记录写到redo log里面，并更新内存，这个时候，更新就算完成了，后续InnoDB会在系统比较空闲的时候，将记录更新到磁盘中。

InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件大小是1GB

<img src="D:\Users\zhou_yao\workspace\just-for-review-and-zhuangB\MySQL\redo log.png" alt="redo log" style="zoom:50%;" />

write pos是当前记录的位置，一边写一边后移，check point是当前要擦除的位置，也是不断后移的，擦除数据之前需要先把记录更新到数据文件中。二者之前的绿色区域即为redo log空余的部分，一旦write pos追上了check point，意味着redo log满了，此时不能继续执行更新操作，需要先擦除一部分数据，再继续接收更新。这样，即便数据库故障重启了，更新的数据也不会丢失，这个能力成为**crash-safe**

##### binlog(重要日志模块)

用于归档，无crash-safe的能力

```
redo log和binlog不同之处
1.redo log是InnoDB独有的，存在于引擎层，而binlog存在于server层
2.redo log是物理日志，记录的是“在某个数据页做了什么修改”；binlog是逻辑日志，记录的是这条语句的原始逻辑，如“把所有c=1的记录c值改成2”
3.redo log是循环写的，空间固定且可以用完；binlog是追加写的，不会覆盖之前的记录，到一定大小后换另一个文件
```

##### 两阶段提交

下图展示了一条更新语句的执行流程

<img src="D:\Users\zhou_yao\workspace\just-for-review-and-zhuangB\MySQL\Two-phase commit.png" alt="Two-phase commit" style="zoom: 50%;" />

其中关于redo log和binlog的部分，成为**两阶段提交**，究其原因，是因为binlog无crash-safe的能力，而redo log有，利用两阶段提交，让binlog数据和redo log一致，这样，使用binlog做数据恢复或者生成备库的时候，可以保证数据的正确性。