### MySQL里的锁大致可以分成全局锁、表锁和行锁三类

#### 全局锁

顾名思义，对整个数据库实例加锁，整个库会处于只读状态，语句是Flush table with read lock（**FTWRL**）。一般存储引擎没法支持一致性读且需要做全库备份的时候使用。

缺陷：

- 如果主库上备份，更新语句都无法执行，业务停摆
- 如果从库上备份，binlog同步无法进行，导致主从延迟

```
全库备份时不使用set global readonly=true的原因：
1.系统可能使用readonly来做其他逻辑，比如判断一个库是主库还是备库
2.若客户端发生异常断开，readonly状态会一直锁定，风险较高，而FTWRL可以自动释放全局锁
```

#### 表级锁

分为两种，**表锁**和**元数据锁**（meta data lock，MDL）

表锁，顾名思义，锁住整个表的锁，一般在不支持行锁的存储引擎的系统中才会使用。

MDL锁保证读写的正确性，不需要显式使用，访问一个表的时候会被自动加上。具体使用上，对一个表做增删改查的时候，加MDL读锁，表结构变更的时候，加MDL写锁，读锁之间不互斥，读写锁，写锁之间互斥，且**MDL锁在事务提交之后才会释放**。

#### 行锁

在存储引擎层实现，针对数据表行记录的锁。在InnoDB事务中，行锁是有需要的时候才加上的，但使用过后，不会马上释放，要等到事务结束之后才释放。这就是**两阶段锁协议**

[^拓展]: 基于两阶段锁协议，如果事务中要锁多个行，可以把冲突比较严重的尽量往后放

##### 死锁和死锁检测

不同线程之间出现循环资源依赖，就会导致死锁。当出现死锁后，有两种策略：

- 直接进入等待，直到等待超时，超时时间可以通过参数innodb_lock_wait_timeout来设置，缺点是超时时间设置多长难以把控
- 死锁检测，发现死锁后，主动回滚链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，即开启了这个逻辑，缺点时如果出现热点行，会严重影响性能，因为检测死锁是一个时间复杂度为O(n)的操作

