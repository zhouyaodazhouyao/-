### MySQL里的锁大致可以分成全局锁、表锁和行锁三类

#### 全局锁

顾名思义，对整个数据库实例加锁，整个库会处于只读状态，语句是Flush table with read lock（**FTWRL**）。一般存储引擎没法支持一致性读且需要做全库备份的时候使用。

缺陷：

- 如果主库上备份，更新语句都无法执行，业务停摆
- 如果从库上备份，binlog同步无法进行，导致主从延迟

```
全库备份时不使用set global readonly=true的原因：
1.系统可能使用readonly来做其他逻辑，比如判断一个库是主库还是备库
2.若客户端发生异常断开，readonly状态会一直锁定，风险较高，而FTWRL可以自动释放全局锁
```

#### 表级锁

分为两种，**表锁**和**元数据锁**（meta data lock，MDL）

表锁，顾名思义，锁住整个表的锁，一般在不支持行锁的存储引擎的系统中才会使用。

MDL锁保证读写的正确性，不需要显式使用，访问一个表的时候会被自动加上。具体使用上，对一个表做增删改查的时候，加MDL读锁，表结构变更的时候，加MDL写锁，读锁之间不互斥，读写锁，写锁之间互斥，且**MDL锁在事务提交之后才会释放**。

#### 行锁

在存储引擎层实现，针对数据表行记录的锁。在InnoDB事务中，行锁是有需要的时候才加上的，但使用过后，不会马上释放，要等到事务结束之后才释放。这就是**两阶段锁协议**

[^拓展]: 基于两阶段锁协议，如果事务中要锁多个行，可以把冲突比较严重的尽量往后放
[^注]: 读提交隔离级别下存在一个优化，语句执行过程中加上的行锁，在语句执行完成后，就要把“不满足条件的行”上的行锁直接释放了，不需要等到事务提交

##### 死锁和死锁检测

不同线程之间出现循环资源依赖，就会导致死锁。当出现死锁后，有两种策略：

- 直接进入等待，直到等待超时，超时时间可以通过参数innodb_lock_wait_timeout来设置，缺点是超时时间设置多长难以把控
- 死锁检测，发现死锁后，主动回滚链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，即开启了这个逻辑，缺点时如果出现热点行，会严重影响性能，因为检测死锁是一个时间复杂度为O(n)的操作

#### 间隙锁

在一行行扫描过程中，不仅给行加上了行锁，还给行两边的空隙，也加上了间隙锁。

间隙锁和行锁有不一样的地方，行锁之间是存在冲突关系的，例如读锁和写锁之间，写锁和写锁之间会存在冲突关系，从而引发阻塞。但是**间隙锁之间是不存在冲突关系的，跟间隙锁存在冲突关系的，是”向这个间隙中插入一个记录“这个操作**。

间隙锁和行锁合称next-key lock，每个next-key lock是前开后闭区间

#### 加锁规则

1. 原则 1：加锁的基本单位是 next-key lock；
2. 原则 2：查找过程中访问到的对象才会加锁；
3. 优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁；
4. 优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁；
5. 一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止（已修复）